package kth.nova.overloadalert.domain.usecases

import kth.nova.overloadalert.data.local.CalendarSyncDao
import kth.nova.overloadalert.data.local.CalendarSyncEntity
import kth.nova.overloadalert.data.local.PlanStorage
import kth.nova.overloadalert.data.remote.EventDateTime
import kth.nova.overloadalert.data.remote.GoogleAuthRepository
import kth.nova.overloadalert.data.remote.GoogleCalendarEvent
import kth.nova.overloadalert.data.remote.GoogleCalendarRepository
import kth.nova.overloadalert.domain.plan.DailyPlan
import kth.nova.overloadalert.domain.plan.RunType
import kth.nova.overloadalert.domain.plan.WeeklyTrainingPlan
import retrofit2.HttpException
import java.util.Locale

private const val CALENDAR_SUMMARY = "Running Training Plan generated by OverloadAlert"

/**
 * Service responsible for synchronizing the [kth.nova.overloadalert.domain.plan.WeeklyTrainingPlan] with a user's Google Calendar.
 *
 * This service handles the creation, update, and deletion of calendar events representing running sessions.
 * It manages a dedicated calendar (identified by [CALENDAR_SUMMARY]) to avoid cluttering the user's primary calendar.
 *
 * Key features:
 * - **Calendar Management:** Automatically finds or creates a specific Google Calendar for the training plan.
 * - **Event Synchronization:** Converts [kth.nova.overloadalert.domain.plan.DailyPlan] entries into all-day calendar events.
 * - **State Tracking:** Uses [kth.nova.overloadalert.data.local.CalendarSyncDao] to map local training days to remote Google Calendar event IDs, allowing updates instead of duplicates.
 * - **Clean Up:** Removes events for rest days or when the plan changes.
 * - **User Edits Preservation:** Attempts to preserve user notes added to the event description and respects user-defined times (if the user converted an all-day event to a timed event).
 * - **Resilience:** Handles cases where events were deleted externally (on the Google Calendar side) by recreating them.
 *
 * @property calendarSyncDao The DAO for accessing local synchronization state records.
 * @property googleCalendarRepository The repository for interacting with the Google Calendar API.
 * @property authRepository The repository for checking authentication status.
 * @property planStorage The storage mechanism for persisting the ID of the dedicated calendar.
 */
class CalendarSyncService(
    private val calendarSyncDao: CalendarSyncDao,
    private val googleCalendarRepository: GoogleCalendarRepository,
    private val authRepository: GoogleAuthRepository,
    private val planStorage: PlanStorage
) {

    private suspend fun getOrCreateCalendar(): String? {
        val storedCalendarId = planStorage.loadCalendarId()
        if (storedCalendarId != null) {
            return storedCalendarId
        }

        // Find or create the calendar
        val newCalendarId = googleCalendarRepository.getOrCreateCalendar(CALENDAR_SUMMARY)

        if (newCalendarId != null) {
            // This is the first time we're using this calendar.
            // Clear any old event sync data that may have pointed to a different calendar (e.g., primary).
            calendarSyncDao.clearAll()
            planStorage.saveCalendarId(newCalendarId)
        }

        return newCalendarId
    }

    suspend fun syncPlanToCalendar(plan: WeeklyTrainingPlan) {
        if (authRepository.getLastSignedInAccount() == null) {
            return
        }

        val calendarId = getOrCreateCalendar() ?: run {
            return
        }

        plan.days.forEach { dailyPlan ->
            val dateStr = dailyPlan.date.toString()
            val syncEntity = calendarSyncDao.getSyncEntity(dateStr)

            // CASE 1: Rest Day.
            // If the plan says REST but we have a synced event for this day, it means
            // there used to be a run here. We must delete it from the calendar.
            if (dailyPlan.runType == RunType.REST) {
                if (syncEntity != null) {
                    try {
                        val response = googleCalendarRepository.deleteEvent(calendarId, syncEntity.googleEventId)

                        // 204 No Content is success. 404/410 means it's already gone.
                        // In all these cases, we should remove the local DB record so we don't try to delete it again.
                        if (response.isSuccessful || response.code() == 404 || response.code() == 410) {
                            calendarSyncDao.deleteSyncEntity(dateStr)
                        }
                    } catch (e: Exception) {
                        // Ignore network/system errors, will retry next sync
                    }
                }
                return@forEach
            }

            // CASE 2: Run Day.
            // We need to ensure an event exists on the calendar.
            val distanceKm = String.Companion.format(Locale.US, "%.1f", dailyPlan.plannedDistance / 1000f)
            val eventTitle = "${dailyPlan.runType.name.lowercase().replaceFirstChar { it.uppercase() }} Run: $distanceKm km"
            val description = "Created by OverloadAlert"

            if (syncEntity != null) {
                // If we already have a record, update the existing event.
                updateEvent(calendarId, syncEntity, dailyPlan, dateStr, eventTitle, description)
            } else {
                // If no record exists, create a new event.
                createEvent(calendarId, dailyPlan, dateStr, eventTitle, description)
            }
        }
    }

    private suspend fun updateEvent(calendarId: String, syncEntity: CalendarSyncEntity, dailyPlan: DailyPlan, dateStr: String, title: String, description: String) {
        try {
            val existingEvent = googleCalendarRepository.getEvent(calendarId, syncEntity.googleEventId)

            // Check if the event is "cancelled" (in trash).
            // This happens if the user manually deleted the event. We want to restore it ("undelete")
            // so the user sees the plan again.
            val isCancelled = existingEvent.status == "cancelled"

            // Check if the user manually set a time for the event.
            // By default, we create all-day events (start.date). If start.dateTime is present, it's a timed event.
            // We preserve this user preference by not overwriting 'start'/'end' fields if it's timed.
            val isTimedEvent = existingEvent.start?.dateTime != null

            // Preserve any notes the user added to the description.
            // We append the user's text after our standard "Created by OverloadAlert" footer.
            val currentDescription = existingEvent.description ?: ""
            val userNotes = if (currentDescription.contains("Created by OverloadAlert")) {
                currentDescription.substringAfter("Created by OverloadAlert")
            } else {
                currentDescription // Preserve whole description if our tag is gone
            }
            val newDescription = "$description$userNotes"

            // If cancelled, explicitly set status to "confirmed" to restore it.
            val eventUpdates = GoogleCalendarEvent(
                summary = title,
                description = newDescription,
                status = if (isCancelled) "confirmed" else null,
                // Only update dates if it's NOT a timed event.
                // If the user set a time, we respect it and don't force it back to all-day.
                start = if (isTimedEvent) null else EventDateTime(date = dateStr),
                end = if (isTimedEvent) null else EventDateTime(date = dateStr)
            )

            googleCalendarRepository.patchEvent(calendarId, syncEntity.googleEventId, eventUpdates)

            calendarSyncDao.insertOrUpdate(
                syncEntity.copy(lastSyncedAt = System.currentTimeMillis(), userModifiedTime = isTimedEvent)
            )
        } catch (e: Exception) {
            // Check if the event is truly gone (404 Not Found or 410 Gone).
            // If getEvent() or patchEvent() failed because the ID is invalid, we must assume the event is lost.
            val isGone = (e is HttpException && (e.code() == 404 || e.code() == 410)) ||
                    (e.message?.let { it.contains("404") || it.contains("410") } == true)

            if (isGone) {
                // Self-healing: Create a new event to replace the missing one.
                createEvent(calendarId, dailyPlan, dateStr, title, description)
            }
        }
    }

    private suspend fun createEvent(calendarId: String, dailyPlan: DailyPlan, dateStr: String, title: String, description: String) {
        try {
            val event = GoogleCalendarEvent(
                summary = title,
                description = description,
                start = EventDateTime(date = dateStr),
                end = EventDateTime(date = dateStr)
            )

            val createdEvent = googleCalendarRepository.createEvent(calendarId, event)

            // Save the mapping between the plan date and the Google Event ID.
            createdEvent.id?.let {
                calendarSyncDao.insertOrUpdate(
                    CalendarSyncEntity(
                        date = dateStr,
                        googleEventId = it,
                        lastSyncedAt = System.currentTimeMillis()
                    )
                )
            }
        } catch (e: Exception) {
            // Ignore error
        }
    }
}
