package kth.nova.overloadalert.domain.usecases

import android.util.Log
import kth.nova.overloadalert.data.local.CalendarSyncDao
import kth.nova.overloadalert.data.local.CalendarSyncEntity
import kth.nova.overloadalert.data.local.PlanStorage
import kth.nova.overloadalert.data.remote.EventDateTime
import kth.nova.overloadalert.data.remote.GoogleAuthRepository
import kth.nova.overloadalert.data.remote.GoogleCalendar
import kth.nova.overloadalert.data.remote.GoogleCalendarEvent
import kth.nova.overloadalert.data.remote.GoogleCalendarRepository
import kth.nova.overloadalert.domain.plan.DailyPlan
import kth.nova.overloadalert.domain.plan.RunType
import kth.nova.overloadalert.domain.plan.WeeklyTrainingPlan
import java.util.Locale
import java.util.TimeZone

private const val CALENDAR_SUMMARY = "Running Training Plan generated by OverloadAlert"

class CalendarSyncService(
    private val calendarSyncDao: CalendarSyncDao,
    private val googleCalendarRepository: GoogleCalendarRepository,
    private val authRepository: GoogleAuthRepository,
    private val planStorage: PlanStorage
) {

    private suspend fun getOrCreateCalendar(): String? {
        val storedCalendarId = planStorage.loadCalendarId()
        if (storedCalendarId != null) {
            return storedCalendarId
        }

        // Find or create the calendar
        val newCalendarId = googleCalendarRepository.getOrCreateCalendar(CALENDAR_SUMMARY)
        
        if (newCalendarId != null) {
            // This is the first time we're using this calendar. 
            // Clear any old event sync data that may have pointed to a different calendar (e.g., primary).
            Log.d("CalendarSyncService", "First time sync with new calendar. Clearing old sync entities.")
            calendarSyncDao.clearAll()
            planStorage.saveCalendarId(newCalendarId)
        }
        
        return newCalendarId
    }

    suspend fun syncPlanToCalendar(plan: WeeklyTrainingPlan) {
        Log.d("CalendarSyncService", "Starting syncPlanToCalendar. Plan days: ${plan.days.size}")

        if (authRepository.getLastSignedInAccount() == null) {
            Log.d("CalendarSyncService", "Not connected to Google Account. Aborting sync.")
            return
        }

        val calendarId = getOrCreateCalendar() ?: run {
            Log.e("CalendarSyncService", "Could not find or create a calendar. Aborting sync.")
            return
        }

        plan.days.forEach { dailyPlan ->
            val dateStr = dailyPlan.date.toString()
            val syncEntity = calendarSyncDao.getSyncEntity(dateStr)

            if (dailyPlan.runType == RunType.REST) {
                if (syncEntity != null) {
                    Log.d("CalendarSyncService", "Deleting event for rest day on $dateStr")
                    try {
                        googleCalendarRepository.deleteEvent(calendarId, syncEntity.googleEventId)
                        calendarSyncDao.deleteSyncEntity(dateStr)
                    } catch (e: Exception) {
                        Log.w("CalendarSyncService", "Failed to delete event ${syncEntity.googleEventId}: ${e.message}")
                    }
                }
                return@forEach
            }

            val distanceKm = String.format(Locale.US, "%.1f", dailyPlan.plannedDistance / 1000f)
            val eventTitle = "${dailyPlan.runType.name.lowercase().replaceFirstChar { it.uppercase() }} Run: $distanceKm km"
            val description = "Created by OverloadAlert"

            if (syncEntity != null) {
                updateEvent(calendarId, syncEntity, dailyPlan, dateStr, eventTitle, description)
            } else {
                createEvent(calendarId, dailyPlan, dateStr, eventTitle, description)
            }
        }
    }

    private suspend fun updateEvent(calendarId: String, syncEntity: CalendarSyncEntity, dailyPlan: DailyPlan, dateStr: String, title: String, description: String) {
        try {
            val existingEvent = googleCalendarRepository.getEvent(calendarId, syncEntity.googleEventId)
            val isTimedEvent = existingEvent.start?.dateTime != null

            val currentDescription = existingEvent.description ?: ""
            val userNotes = if (currentDescription.contains("Created by OverloadAlert")) {
                currentDescription.substringAfter("Created by OverloadAlert")
            } else {
                currentDescription // Preserve whole description if our tag is gone
            }
            val newDescription = "$description$userNotes"

            val eventUpdates = GoogleCalendarEvent(
                summary = title,
                description = newDescription,
                start = if (isTimedEvent) null else EventDateTime(date = dateStr),
                end = if (isTimedEvent) null else EventDateTime(date = dateStr)
            )

            googleCalendarRepository.patchEvent(calendarId, syncEntity.googleEventId, eventUpdates)
            calendarSyncDao.insertOrUpdate(
                syncEntity.copy(lastSyncedAt = System.currentTimeMillis(), userModifiedTime = isTimedEvent)
            )
        } catch (e: Exception) {
            Log.e("CalendarSyncService", "Error updating event $dateStr", e)
            if (e.message?.contains("404") == true) {
                createEvent(calendarId, dailyPlan, dateStr, title, description)
            }
        }
    }

    private suspend fun createEvent(calendarId: String, dailyPlan: DailyPlan, dateStr: String, title: String, description: String) {
        try {
            val event = GoogleCalendarEvent(
                summary = title,
                description = description,
                start = EventDateTime(date = dateStr),
                end = EventDateTime(date = dateStr)
            )

            val createdEvent = googleCalendarRepository.createEvent(calendarId, event)
            Log.d("CalendarSyncService", "Event created: ${createdEvent.id}")

            createdEvent.id?.let {
                calendarSyncDao.insertOrUpdate(
                    CalendarSyncEntity(date = dateStr, googleEventId = it, lastSyncedAt = System.currentTimeMillis())
                )
            }
        } catch (e: Exception) {
            Log.e("CalendarSyncService", "Error creating event", e)
        }
    }
}